# ----------------- 3-rd Order Polynomial Interpolation Utilities ----
def generate_trajectory_3rd_order(waypoints, velocities, position_limits, max_velocity, max_acceleration, tf, T):
    """
    Given a list of waypoints and a list of velocities to pass over each
    waypoint and the total time tf to perform this motion with time interval 
    of T is computes the successive positions and composes the trajectory.
    :param waypoints : list of waypoints (each a 3-element list (x,y,z))
    :param velocities: list of velocities (each a 3-element list (vx,vy,vz))
    :position_limits : list of a pair of limits for each coordinate ([min_x, max_x], [min_y, max_y], [min_z, max_z])
    :max_velocity    : the maximum velocity permited in means of magnitude (norm(V))
    :max_acceleration: the maximum acceleration permited in means of magnitude (norm(a))
    :param tf        : total time for the motion
    :return          : list of waypoints and the velocities at each point if valid.
    """
    is_valid = True # If false then something is out of range!

    x_lim, y_lim, z_lim = position_limits

    # Log trajectory points and velocity for each point
    trajectory_out   = []
    velocity_out     = []
    acceleration_out = []

    N = round(tf / T) # The number of timesteps to generate

    # iterate through all waypoints
    for k in range(len(waypoints)-1):
        x0, y0, z0 = waypoints[k]    # starting point on the trajectory
        x1, y1, z1 = waypoints[k+1]  # final point on the trajectory
        vx0, vy0, vz0 = velocities[k]    # initial velocity
        vx1, vy1, vz1 = velocities[k+1]  # final velocity

        # Find the cubic polynomial coefficients
        a0x, a1x, a2x, a3x = poly3_interpollation(x0, vx0, x1, vx1, tf)
        a0y, a1y, a2y, a3y = poly3_interpollation(y0, vy0, y1, vy1, tf)
        a0z, a1z, a2z, a3z = poly3_interpollation(z0, vz0, z1, vz1, tf)

        # compute the via points per time-step
        for n in range(0, N):
            x = evaluate_poly3(a0x, a1x, a2x, a3x, n * T)
            y = evaluate_poly3(a0y, a1y, a2y, a3y, n * T)
            z = evaluate_poly3(a0z, a1z, a2z, a3z, n * T)
            
            # Check if the positions computed are within the workspace of the robot
            if x <= x_lim[0] or x >= x_lim[1]:
                print(f"[WARNING] x is out of range: {x}")
                is_valid = False
                break
            
            if y <= y_lim[0] or y >= y_lim[1]:
                print(f"[WARNING] y is out of range: {y}")
                is_valid = False
                break
                
            if z <= z_lim[0] or z >= z_lim[1]:
                print(f"[WARNING] z is out of range: {z}")
                is_valid = False
                break

            trajectory_out.append(np.array([x, y, z]))     

        # Stop the first loop if the nedted ones are terminated with error
        if not is_valid:
            break

    # compute the velocities per time step
    for n in range(0, len(trajectory_out)-1):
        xi, yi, zi = trajectory_out[n]
        xf, yf, zf = trajectory_out[n+1]

        vx = (xf - xi) / T
        vy = (yf - yi) / T
        vz = (zf - zi) / T
        
        mag_v = np.sqrt(vz**2 + vy**2 + vz**2)
        if mag_v > max_velocity:
            print(f"[WARNING] velocity is out of bound: ({vx}, {vy}, {vz}), |v| = {mag_v}")
            is_valid = False
            break
 
        velocity_out.append(np.array([vx, vy, vz]))

    # compute the acceleration per time step
    for n in range(0, len(velocity_out)-1):
        vxi, vyi, vzi = velocity_out[n]
        vxf, vyf, vzf = velocity_out[n+1]

        ax = (vxf - vxi) / T
        ay = (vyf - vyi) / T
        az = (vzf - vzi) / T
        
        mag_a = np.sqrt(ax**2 + ay**2 + az**2)
        if mag_a > max_acceleration:
            print(f"[WARNING] acceleration is out of bound: ({ax}, {ay}, {az}), |a| = {mag_a}")
            is_valid = False
            break 

        acceleration_out.append(np.array([ax, ay, az]))

    return trajectory_out, velocity_out, acceleration_out, is_valid

def poly3_interpollation(p0, v0, pf, vf, tf):
    """
    Compute the coefficients of a 3rd order polynomial interpolation
    :param p0 : initial position (single coordinate)
    :param v0 : initial velocity (single speed value)
    :param pf : final position (single coordinate)
    :param vf : final velocity (single speed value)
    :param tf : total time for the motion
    returns the computed coefficients of the polynomial
    """
    a0 = p0
    a1 = v0
    a2 = (3/tf**2) * (pf - p0) - (2/tf) * v0 - (1/tf) * vf 
    a3 = -(2/tf**3) * (pf - p0) + (1/tf**2) * (v0 + vf)
    return [a0, a1, a2, a3]

def evaluate_poly3(a0, a1, a2, a3, t):
    """
    Evaluates the 3-rd order polynomial with coefficients
    a0, a1, a2, a3 at time instant t. Returns the evaluated value.
    """
    return a0 + a1 * t + a2 * t**2 + a3 * t**3

